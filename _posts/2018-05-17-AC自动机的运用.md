---
layout:     post
title:      "AC自动机的运用"
subtitle:   "树！"
date:       2018-05-17 12:00:00
author:     "Aspe"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 算法
    - AC自动机
    - DP
    - 树
---

## 声明
  对于后缀结点和失配指针两种说法，本文采用后缀(Next)结点这种说法。  
  这里说的后缀树，并不是真正的所谓的后缀树。只是后缀树的一种，或者说，是一种广义的后缀树。  

---

## AC自动机
  见旧站：http://yhf4aspe.blog.163.com/blog/static/246803084201821774912487/

---

## 注意
  前缀后缀什么的不要晕啊！要有耐心去分析！  
  Trie树，就是前缀树。  
  **前缀的后缀是匹配。**  
  我们用AC机解决后缀，构造出后缀树。  

---

## AC自动机优化DP
   用一道例题引入以下  
   给出几个模式串（一个字典）比如：A、AB  
   定义一个字符串S的得分：模式串在S中出现的次数。比如：ABAB的分数为4  
   构造一个长度为L的字符串使得分最高，输出最高得分。  
   
   S的得分可以理解成这样，枚举S的前缀si，再用si的后缀与模式串匹配（抽象吧，其实就是枚举匹配的结束点）。这样的话得分就可以用一个递推来表达了。  
   f_S=sum(f_si); f_i=f_(i-1)+f_si; f_S=f_len （其中f_si的求就是在AC机上查询一趟）  
   
   然而，题目要求的是构造，这可能会对我们造成很大疑惑，但是理解了如何得分，会对我们用DP解决此题有很大帮助。  
   
   先想到一维，也就是枚举前缀si，当然只有一维是不够的，我们还需要能求出f_si的一些信息，所以状态大概是这样的  
   f[i][x]，其中x表示一个字符串，可以通过f[i-1][y]推得，其中x=y+X，也就是在y的后面再加了一个字符。  
   这样我们的转移方程就出来了，f[i][y+ch]=f[i-1][y]  
   
   这就得到了最原始的DP，但我们发现，记录x的代价是很高的，所以要优化，我们可以发现，有些字符串是不用记录的，并不会作为状态。  
   那么是怎样的字符串才会作为状态呢？即为：**能对当前或以后做贡献的字符串才保留**。也就是，能使当前的得分增加或将来能的字符串。  
   仔细想想，也就是每个模式串的前缀，也就是枚举**Tire树上的每个结点**。  
   
   所以方程就优化成了这样f[i][j](1<=i<=L && j is a node of Tire tree)f[i][p->ch]=f[i-1][p]+Query(p,ch)大概是这样的。  
   我们可以先预处理Query(p,ch)这样就可以，在O(len×size)的时间解决。  
   
   这大概是AC自动机对DP优化的思路，**能对当前或以后做贡献的字符串才保留**，而这些字符串也就是**Tire树上的每个结点**。  
   总的来说，用Tire缩小状态，用AC自动机快速查询。  

---

## Next树
  就是在跑过AC机的Trie树上，用求出的Next结点构成的新树（因为只有一条出边，所以是一棵树）。  
  毕竟AC自动机就是一个求Next的算法，那么我们把构成的这棵树研究透彻了，会对AC机的应用大有帮助。  
  这是一棵Trie树和用其构造出的Next树：  
  
  可能有点简单，可以自己画一个更大的去理解。  
  
  这棵树有什么性质呢？其实只需根据**Next结点的定义**。可以得出这么个结论：  
  ·在Next树上，u是v的父亲（祖先），那么st_u是st_v的后缀·  
  其实这个Next树，就是一个后缀树。  
 
 
 ---
 
 ## AC自动机与树综合
 
 ---
